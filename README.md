# Data-Structure-Course-work-record  
## DS1ex1  
* ### 老鼠走迷宮
  #### 任務一
  * 創造兩個迷宮物件及一個老鼠的物件，分別存取走過的路徑、能抵達目標的路徑以及尋訪迷宮，利用遞迴的方式使老鼠在迷宮中行走。  
  * 若遇到障礙物，以“右下左上”的順序依序尋找能夠移動的路線，直到找到目標為止，若沒有辦法找到目標，回傳 false 值並印出走過的路徑。
  * 若有找到目標，回傳 true 值，接著印出走過的路徑及到達目標的路線。
  #### 任務二
  * 大致與任務一相同
  * 唯一差別為有多個目標
  #### 任務三
  * 大致與任務一相同
  * 差別為須尋找出找到目標的最短路徑
  
## DS1ex2  
* ### 判斷前序式是否合法及轉換前序式為後續式
  #### 任務一
  * 用 string 的型別存取輸入的 infix expression，接著依序判斷此前序式是否合法：  
    1. 若出現除了括弧或加減乘除之外的符號(e.g. ^, %) → 非法前序式(運算子錯誤)  
    2. 若括弧沒有成對出現(e.g. (9*(9+2))) ) → 非法前序式(括弧不對稱)  
    3. 若出現其他非法情況(e.g. 9(5+6), (+3*9) ) → 非法前序式(其餘狀況)
  * 若皆無上述情況，即該前序式合法。
  #### 任務二
  * 一個一個判斷前序式中每一個字元：  
    1. 若該字元為數字 → 存進 operand 的 string  
    2. 若該字元為運算子 → 將 operand 加入存放 postfix 的 linked list  
      1. 若該運算子為右括弧 → 直接存進 stack  
      2. 若該運算子為左括弧 → 將在右括弧之後存進 stack 的運算子存進 postfix  
      3. 若該運算子為 * 或 /  
         * 若前一個存放進 stack 的運算子為 * 或 / → 先將前一個運算子存入 postfix 並刪除，再將目前的運算子加入 stack  
         * 若前一個存放進 stack 的運算子為括弧或 +, - → 直接將目前的運算子加入 stack  
      4. 若該運算子為 + 或 –→ 將之前的存進的運算子存入 postfix 直到遇到左括弧或 stack 為空  
    3. 若 operand 中仍有東西或 stack 中仍有運算符 → 存進 postfix  
  * 最後輸出轉換後的後序式。
  #### 任務三
  * 計算任務二轉換後後序式的結果  

## DS1ex3  
* ### 優先佇列 (Priority Queue)
  #### 任務一
  * 用 vector 存讀入的文字檔資料，用希爾排序法對資料中的 arrival 進行排序
  * 若 arrival 數值相同，則對 OID 的數值進行排序，排序完成後以文字檔輸出
  #### 任務二
  * 模擬單一 CPU 佇列的執行過程，抓取並刪除已排序資料中的第一筆數據
    * 若 CPU 目前無執行項目且佇列為空，則執行該資料
    * 若佇列不為空，則更新佇列中資料後，視情況將該資料放入 CPU 執行或放入佇列中
  * 若目前 CPU 有執行項目，且佇列已滿，則將該資料放入「取消執行清單」中
  * 若佇列未滿，則將資料放入佇列中。若處理完所有已排序資料，處理並清空佇列。
  #### 任務三
  * 模擬兩個佇列的執行過程

## DS1ex4 
* ### 二元搜尋樹 (Binary Search Tree)
  #### 任務一
  * 將輸入的檔案存進 vector 中，再分別以資料的學校名稱及上學年度畢業人數建構兩棵二元搜尋樹
  * 計算樹高後，個別輸出
  #### 任務二
  * 若輸入指令為 2：  
    → 輸入一非負整數  
    → 搜尋並印出上學年度畢業人數大於或等於該負整數的學校資料
  * 若輸入指令為 3：
    → 輸入一學校名稱
    → 搜尋並印出該和學校名稱相同的學校資料
  #### 任務三
  * 根據特定學校名稱從二元搜尋樹中移除資料

## DS1ex5  
* ### 二元搜尋數 (Binary Search Tree)、堆積 (Heap)
  #### 任務一
  * 將輸入的檔案存進 vector 中，以資料的生命值 HP 為鍵值建立一棵二元搜尋樹
  * 計算樹高、尋找最右側節點及最左側節點
  * 輸出資料內容、樹高、最左及最右側節點
  #### 任務二
  * 將任務一輸入時存資料的 vector 轉成以生命值 HP 為鍵值的 Max Heap
  * 算 Heap 高度、尋找最左側節點及 bottom 的資料
  * 完成後依 vector 中的次序輸出資料內容、Heap高度、最左側節點及 bottom 的值。
  
## DS2ex1  
* ### 最大堆積 (Max Heap)、雙堆積 (Deap)
  #### 任務一
  * 將輸入的檔案存進 vector 中，將檔案中的每筆資料附上唯一序號後
  * 依序存入以「學生數」建立的最大堆積(max heap)中
  * 完成後找到並顯示樹根、底部節點及最左下角節點的序號和學生數於螢幕上
  #### 任務二
  * 將輸入的檔案存進 vector 中，將檔案中的每筆資料附上唯一序號
  * 依序存入以「學生數」建立的雙堆積(DEAP)中
  * 完成後找到並顯示樹根及底部節點的序號和學生數於螢幕上
  #### 任務三
  * 輸入一個介於1 ~ Deap size的值 k
  * 取得任務二建立的 Deap 中的前 k 個最大值

## DS2ex2  
* ### 2-3樹
  #### 任務一
  * 將輸入的檔案存進 vector 中，將檔案中的每筆資料附上序號後
  * 依序存入以「上學年度畢業生人數」建立的 2-3 樹中
  * 完成後找到並顯示樹根內儲存的所有資料、樹高及節點數於螢幕上
  #### 任務二
  * 將任務一讀入檔案中的資料依序存入以「學生數」建立的 AVL 樹中
  * 完成後找到並顯示樹根內儲存的所有資料、樹高和節點數於螢幕上
  #### 任務三
  * 取得任務一中建立的 2-3樹 中的前 k 個最大值
  * 取得任務二中建立的 AVL樹 中的前 k 個最大值
  
## DS2ex3  
* ### 平方探測 (Quadratic probing)、雙重雜湊 (double hashing)
  #### 任務零
  * 讀入文字檔，將檔案中的學號、姓名、分數(六個)、平均分數
  * 以10位元char陣列, unsinged char型態, float型態的形式儲存至struct中
  * 以struct的形式寫入並輸出同名的二進位檔
  #### 任務一
  * 依序讀入二進位檔中的資料
  * 以平方探測 (quadratic probing)、學號為鍵值建立雜湊表，並計算搜尋不存在值及搜尋現存值的平均比較次數
  * 完成後將平均比較次數顯示於螢幕上並輸出存有雜湊表所有資料的文字檔
  #### 任務二
  * 依序讀入二進位檔中的資料
  * 以雙重雜湊(double hashing)、學號為鍵值建立雜湊表，並計算搜尋現存值的平均比較次數
  * 完成後將平均比較次數顯示於螢幕上並輸出存有雜湊表所有資料的文字檔

## DS2ex4  
* ### 寬度優先搜尋 (BFS)
  #### 任務一
  * 讀取二進位檔，以struct存取輸入資料的發訊者學號(12位元)、收訊者學號(12位元)和權重(float)
  * 接著依序將資料放入以發訊者學號為主陣列的相鄰串列
  * 完成後將相鄰串列輸出為副檔名.adj的文字檔
  #### 任務二
  * 從一個發訊者學號開始以寬度優先BFS走訪相鄰節點
  * 紀錄路徑並計算其連通數
  * 完成後將各發訊者學號的聯通數及路徑輸出為副檔名為.cnt的文字檔

## DS2ex5  
* ### 外部排序
  #### 任務一
  * 將讀取的二進位檔中的資料以外部排序依照「量化權重」由大到小排序(權重大小一樣時，保持原始檔案內的順序)
  * 將排序結果寫成另一個二進位檔
  * 測量並輸出整體執行時間
  #### 任務二
  * 讀取任務一產生的排序檔
  * 以「量化權重」為排序檔建立主索引(只記錄量化權重weight及檔案位置offset)
  * 建立完成後將主索引儲存的weight和offset依序顯示於螢幕上
